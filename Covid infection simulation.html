<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Covid infection sumulation - jorgedf2</title>
    <script src="https://d3js.org/d3.v3.min.js"></script>
</head>
<body>

<script>
    var balls = []; // global array representing balls
    var timercount = 0;
	var infectiousLength = 230;
	var maskWearing = 0;
	var maskWearingInfectProb = 0.50;
	var startStopFlag = null;
	var infectionToDeathTime = infectiousLength * 0.7;
	var deathRate = 0.018;
	var percentPopVaccinated = 0.0;
	var bH = 10;
	var bV = 10;
	var popSize = 100;
	/*
	Colors:
	"red" = infected
	"#b5d4e9" = uninfected
	"orange" = recovered
	"#67000d" = deceased
	"#0a4a90" = vaccinated
	*/
	
	// Ball object - multiple balls can be created by instantiating new objects
    function Ball(svg, x, y, id, color, aoa, weight,timeInfected,infected,vaccinated) {
        this.posX = x; // cx
        this.posY = y; // cy
        this.color = color;
        this.radius = weight; // radius and weight same
        this.jumpSize = 1; // equivalent of speed default to 1
        this.svg = svg; // parent SVG
        this.id = id; // id of ball
        this.aoa = aoa; // initial angle of attack
        this.weight = weight;
		this.timeInfected = timeInfected;
		this.infected = infected;
		this.recovered = 0;
		this.deceased = 0;
		this.vaccinated = vaccinated;
		this.deathProbability = Math.random();
		

        if (!this.aoa)
            this.aoa = Math.PI / 7;
        if (!this.weight)
            this.weight = 10;
        this.radius = this.weight;

        this.data = [this.id]; // allow us to use d3.enter()

        var thisobj = this; // i like to use thisobj instead of this. this many times not reliable particularly handling evnet

        // **** aoa is used only here -- earlier I was using to next move position.
        // Now aoa and speed together is velocity 
        this.vx = Math.cos(thisobj.aoa) * thisobj.jumpSize; // velocity x
        this.vy = Math.sin(thisobj.aoa) * thisobj.jumpSize; // velocity y
        this.initialVx = this.vx;
        this.initialVy = this.vy;
        this.initialPosX = this.posX;
        this.initialPosY = this.posY;

        // when speed changes, go to initial setting
        this.GoToInitialSettings = function (newjumpSize) {
            thisobj.posX = thisobj.initialPosX;
            thisobj.posY = thisobj.initialPosY;
            thisobj.vx = Math.cos(thisobj.aoa) * newjumpSize; // velocity x
            thisobj.vy = Math.sin(thisobj.aoa) * newjumpSize; // velocity y
            thisobj.Draw();
        }

        this.Draw = function () {
            var svg = thisobj.svg;
            var ball = svg.selectAll('#' + thisobj.id)
                        .data(thisobj.data)
                    ;
					
            ball.enter()
                .append("circle")
                .attr({"id" : thisobj.id, 'class' : 'ball', 'r' : thisobj.radius, 'weight' : thisobj.weight})
                .style("fill", thisobj.color)
                ;
            ball
                //.transition()//.duration(50)
                .attr("cx", thisobj.posX)
                .attr("cy", thisobj.posY)
				.style("fill", thisobj.color)
            ;
			if(maskWearing ==1)
			{
			ball.style("stroke",'blue');
			}
			
			if(this.infected == 0 && this.vaccinated == 1)
			{
			ball.style("fill", "#0a4a90");}
			

            // intersect ball is used to show collision effect - every ball has it's own intersect ball
            var intersectBall = ball.enter()
                                .append('circle')
                                .attr({ 'id': thisobj.id + '_intersect', 'class': 'intersectBall' });
        }

        this.Move = function () {
            var svg = thisobj.svg;

            //thisobj.posX += Math.cos(thisobj.aoa) * thisobj.jumpSize;
            //thisobj.posY += Math.sin(thisobj.aoa) * thisobj.jumpSize;

            thisobj.posX += thisobj.vx;
            thisobj.posY += thisobj.vy;

            if (parseInt(svg.attr('width')) <= (thisobj.posX + thisobj.radius)) {
                thisobj.posX = parseInt(svg.attr('width')) - thisobj.radius - 1;
                thisobj.aoa = Math.PI - thisobj.aoa;
                thisobj.vx = -thisobj.vx;
            }

            if ( thisobj.posX < thisobj.radius) {
                thisobj.posX = thisobj.radius+1;
                thisobj.aoa = Math.PI - thisobj.aoa;
                thisobj.vx = -thisobj.vx;
            }

            if (parseInt(svg.attr('height')) < (thisobj.posY + thisobj.radius)) {
                thisobj.posY = parseInt(svg.attr('height')) - thisobj.radius - 1;
                thisobj.aoa = 2 * Math.PI - thisobj.aoa;
                thisobj.vy = -thisobj.vy;
            }

            if (thisobj.posY < thisobj.radius) {
                thisobj.posY = thisobj.radius+1;
                thisobj.aoa = 2 * Math.PI - thisobj.aoa;
                thisobj.vy = -thisobj.vy;
            }

            // **** NOT USING AOA except during initilization. Just left this for future reference ***** 
            if (thisobj.aoa > 2 * Math.PI)
                thisobj.aoa = thisobj.aoa - 2 * Math.PI;
            if (thisobj.aoa < 0)
                thisobj.aoa = 2 * Math.PI + thisobj.aoa;

            thisobj.Draw();
        }
    }

    function CheckCollision(ball1, ball2) {
        var absx = Math.abs(parseFloat(ball2.posX) - parseFloat(ball1.posX));
        var absy = Math.abs(parseFloat(ball2.posY) - parseFloat(ball1.posY));

        // find distance between two balls.
        var distance = (absx * absx) + (absy * absy);
        distance = Math.sqrt(distance);
        // check if distance is less than sum of two radius - if yes, collision
        if (distance < (parseFloat(ball1.radius) + parseFloat(ball2.radius))) {
            return true;
        }
        return false;
    }

    
    //courtsey thanks to several internet sites for formulas
    //detect collision, find intersecting point and set new speed+direction for each ball based on weight (weight=radius)
    function ProcessCollision(ball1, ball2) {

		
		
        if (ball2 <= ball1)
            return;
        if (ball1 >= (balls.length-1) || ball2 >= balls.length )
            return;

        ball1 = balls[ball1];
        ball2 = balls[ball2];

		
			
        if ( CheckCollision(ball1, ball2) ) {
            // intersection point
            var interx = ((ball1.posX * ball2.radius) + ball2.posX * ball1.radius)
            / (ball1.radius + ball2.radius);
            var intery = ((ball1.posY * ball2.radius) + ball2.posY  * ball1.radius)
            / (ball1.radius + ball2.radius);

            // show collision effect for 500 miliseconds
            /*var intersectBall = svg.select('#' + ball1.id + '_intersect');
            intersectBall.attr({ 'cx': interx, 'cy': intery, 'r': 5 ,'fill': 'black' })
                        .transition()
                        .duration(500)
                        .attr('r', 0);*/
			
			if(ball1.infected == 1 || ball2.infected == 1)
					{
					if(maskWearing == 1)
						{
						if ( Math.random() <= maskWearingInfectProb )
							{
							
							if(ball1.infected == 0 && ball1.recovered == 0 && ball1.deceased == 0 && ball1.vaccinated == 0)
								{
								ball1.timeInfected = timercount;
								ball1.color = 'red';
								ball1.infected = 1 ;
								}
							
							if(ball2.infected == 0 && ball2.recovered == 0 && ball2.deceased == 0 && ball2.vaccinated == 0)
								{
								ball2.timeInfected = timercount;
								ball2.color = 'red';
								ball2.infected = 1 ;
								}
							console.log('new covid infection');
							}
						}
						else
						{
						
						
						if(ball1.infected == 0 && ball1.recovered == 0 && ball1.deceased == 0 && ball1.vaccinated == 0)
							{
							ball1.timeInfected = timercount;
							ball1.color = 'red';
							ball1.infected = 1 ;
							}
						
						if(ball2.infected == 0 && ball2.recovered == 0 && ball2.deceased == 0 && ball2.vaccinated == 0)
							{
							ball2.timeInfected = timercount;
							ball2.color = 'red';
							ball2.infected = 1 ;
							}
						console.log('new covid infection');
						
						}
					}

            // calculate new velocity of each ball.
            var vx1 = (ball1.vx * (ball1.weight - ball2.weight)
                + (2 * ball2.weight * ball2.vx )) / (ball1.weight + ball2.weight);
            var vy1 = (ball1.vy * (ball1.weight - ball2.weight)
                + (2 * ball2.weight * ball2.vy)) / (ball1.weight + ball2.weight);
            var vx2 = (ball2.vx * (ball2.weight - ball1.weight)
                + (2 * ball1.weight * ball1.vx)) / (ball1.weight + ball2.weight);
            var vy2 = (ball2.vy * (ball2.weight - ball1.weight)
                + (2 * ball1.weight * ball1.vy)) / (ball1.weight + ball2.weight);

            //set velocities for both balls
            ball1.vx = vx1;
            ball1.vy = vy1;
            ball2.vx = vx2;
            ball2.vy = vy2;

            //ensure one ball is not inside others. distant apart till not colliding
            while (CheckCollision(ball1, ball2)) {
                ball1.posX += ball1.vx;
                ball1.posY += ball1.vy;

                ball2.posX += ball2.vx;
                ball2.posY += ball2.vy;
				
				
				
            }
			
			
			
			ball1.Draw();
            ball2.Draw();
        }
    }

    function Initialize(containerId) {
        var height = document.getElementById(containerId).clientHeight;
        var width = document.getElementById(containerId).clientWidth;
        gContainerId = containerId;
		d3.selectAll('svg').remove();
        balls = [];
		gCanvasId = containerId + '_canvas';
        gTopGroupId = containerId + '_topGroup';
        var svg = d3.select("#" + containerId).append("svg")
            .attr("id", gCanvasId)
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("id", gTopGroupId)
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", width)
            .attr("height", height)
            .style("fill", "none")
        //.attr("transform", "translate(" + 1 + "," + 1 + ")")
        ;
		
		
        
			for (var i = 1; i <= 44 ; ++i) {
				vaccinated = 0;
				if (Math.random() < percentPopVaccinated)
				{vaccinated = 1;}
				
				balls.push(new Ball(svg, hi(i,bH,width), vi(i,bH,bV,height), 'n'+(i+1).toString(), "#b5d4e9", 2*Math.PI * Math.random(), 10,-1,0, vaccinated));
				}
			var j = 45
			
			balls.push(new Ball(svg, hi(j,bH,width), vi(j,bH,bV,height), 'n' + (j+1).toString() , 'red', 2*Math.PI * Math.random(), 10,timercount,1,0));
			
			for (var i = 46; i <= popSize ; ++i) {
				vaccinated = 0;
				if (Math.random() < percentPopVaccinated)
				{vaccinated = 1;}
				
				balls.push(new Ball(svg, hi(i,bH,width), vi(i,bH,bV,height), 'n'+(i+1).toString(), "#b5d4e9", 2*Math.PI * Math.random(), 10,-1,0, vaccinated));
				}

        for (var i = 0; i < balls.length; ++i) {
            balls[i].Draw();
        }
        return svg;
    }
	
	// initial horizontal positioning
	function hi(a,bH,width) {
		  let result;
		  if (a%bH == 0) {
			result = bH;
		  } else {
			result = a%bH;
		  }
		  return Math.floor(25 + (result-1) *((width-50)/(bH-1)));
		}
	
	// initial vertical positioning
	function vi(a,bH,bV,height) {
		  let result;
			
		  var row = 0;
		  if (a%bH == 0) {
			row = Math.floor(a/bH)-1;
		  } else {
			row = Math.floor(a/bH);
		  }
		  result = Math.floor(25 + row * ((height-50)/(bV-1)));
		  
		  return result;
		}
	
	// infection transition to recovered or deceased
	function infectionExpiration(ball)
	{
		ball = balls[ball];
		
		
		if(ball.infected == 1  && ball.recovered == 0  && ball.deceased == 0 && (timercount - ball.timeInfected)> infectionToDeathTime && ball.deathProbability <= deathRate)
			{
			ball.recovered = 0;
			ball.infected = 0;
			ball.deceased = 1
			ball.color = '#67000d';
			console.log('new covid death')
			
			}
		
		if(ball.infected == 1  && ball.recovered == 0 && ball.deceased == 0 && (timercount - ball.timeInfected)> infectiousLength)
			{
			ball.recovered = 1;
			ball.infected = 0;
			ball.color = 'orange';
			console.log('new covid recovery')
			
			}
		
	}
    
    function StartStopToggle() {
		
        if (startStopFlag == null) {
            d3.timer(function () {
				timercount +=1;
                
				for (var i = 0; i < balls.length; ++i) {
					
                    var r = balls[i].Move();
					infectionExpiration(i);
                    for (var j = i + 1; j < balls.length; ++j) {
                        ProcessCollision(i, j);
                    }
                }
                if (startStopFlag == null)
                    return true;
                else
                    return false;
            }, 500);
            startStopFlag = 1;
            document.getElementById('startStop').innerHTML = 'Stop';
        }
        else {
            startStopFlag = null;
            document.getElementById('startStop').innerHTML = 'Start';
        }
    }

    
	
	
	
	function reStart(containerId)
		{
		gCanvasId = containerId + '_canvas';
		var svg = d3.select("#" + gCanvasId);
		svg.selectAll("*").remove();
		Initialize(containerId)
		}
	
	function onMaskWearingChange(containerId)
		{
		var maskWselect =  document.getElementById('maskWearingPopulation');
		maskWearing = maskWselect.options[maskWselect.selectedIndex].value;
		console.log("Mask Wearing: " + maskWearing);
		reStart(containerId);
		}
		
	function onPerPopChange(containerId)
		{
		var perPopSelect = document.getElementById('percentPopulationVaccinated');
		percentPopVaccinated =  perPopSelect.options[perPopSelect.selectedIndex].value;
		console.log("Per Population Vaccinated: " + percentPopVaccinated);
		reStart(containerId);
		}

</script>
<div id="mainDiv" style="width:800px; height:600px">
    <div id="drawAreaOuter" style="width:100%; height:100%;  ">
        <div id="menuTop" >
            <a id="startStop" href="javascript:StartStopToggle()">Start</a> | 
			<a id="restart" href="javascript:reStart('drawArea')">Restart</a> 
             | Mask Wearing :
            <select id='maskWearingPopulation' onchange="onMaskWearingChange('drawArea')">
                <option value="0" selected="selected">No</option>
                <option value="1" >Yes</option>
                
            </select>
			 | % Pop Vaccinated :
            <select id='percentPopulationVaccinated' onchange="onPerPopChange('drawArea')">
                <option value=0 selected="selected">0 %</option>
                <option value=0.35 >35%</option>
                <option value=0.45 >45%</option>
				<option value=0.55 >55%</option>
				<option value=0.65 >65%</option>
				<option value=0.75 >75%</option>
            </select>
        </div>
        <div id="drawArea" style="width:100%; height:100%; border:1px solid gray">
        </div>
    </div>
</div>

<script>
    var svg = Initialize('drawArea');
</script>

</body>
</html>