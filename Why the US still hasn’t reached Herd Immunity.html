<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<script src="https://d3js.org/d3.v5.min.js"></script>
	<script src="https://d3js.org/topojson.v2.min.js"></script>
	<title> Why the US still hasn’t reached Herd Immunity? </title>
	<style>
		body {
				font-family: Arial, sans-serif;
				font-size: 16px;
			}
</style>
</head>

<body lang=EN-US link="#0563C1" vlink="#954F72" style='tab-interval:.5in;
word-wrap:break-word; margin-left:20%; margin-right:20%; padding:0'>

<div>

<h1 align=center style='text-align:center'><u>Why the US still hasn’t reached
Herd Immunity?<o:p></o:p></u></h1>

<p ><o:p>Jorge Flores (jorgedf2@illinois.edu)</o:p></p>

<p ><o:p>&nbsp;</o:p></p>

<p >The Covid Pandemic has taken a great tool in the US, both as
economical impact as well as lives lost. In almost every state there has been
Covid Vaccines readily available for every age group since early March 2021.
Yet, as of July 25<sup>th</sup>, 2021, only 49.4% of the population is fully
vaccinated and 57% have at least one dose (<span class=SpellE><a
href="https://www.mayoclinic.org/coronavirus-covid-19/vaccine-tracker">MayoClinic</a></span>).
So, what will it take to get the rest of the population vaccinated and why aren’t
they taking the vaccine anyways?</p>

<p >In the following visualizations, we first explore how Covid
infections work. You will be able to see what happens when covid starts
spreading in a population where there is no immunity, what happens when people start
using masks and what happens when people start getting vaccinated at different
rates.</p>

<p >Then we will explore what is the current situation on
different counties across different states (<a
href="https://github.com/nytimes/covid-19-data/tree/master/rolling-averages">NYTimes</a>),
and compare this with the next visualization where we explore the level of
hesitancy in these same counties and how there is a strong correlation between
the current states and this level of hesitancy (<a
href="https://data.cdc.gov/Vaccinations/Vaccine-Hesitancy-for-COVID-19-County-and-local-es/q9mh-h2tw">CDC</a>).</p>


<script>
    var subjects = []; // array of all patients / pouplation
    var timercount = 0;
	var infectiousLength = 230;
	var maskWearing = 0;
	var maskWearingInfectProb = 0.94;
	var startStopFlag = 0;
	var infectionToDeathTime = infectiousLength * 0.7;
	var deathRate = 0.018;
	var percentPopVaccinated = 0.0;
	var bH = 10;
	var bV = 10;
	var popSize = 100;
	var deceasedCount = 0;
	var infectedCount = 0;
	var uninfectedCount = popSize;
	var vaccinatedCount = 0;
	var recoveredCount = 0;
	var legend = null;
	var timer = null;
	/*
	Colors:
	"red" = infected
	"#b5d4e9" = uninfected
	"orange" = recovered
	"#67000d" = deceased
	"#0a4a90" = vaccinated
	*/
	
	// Ball object - multiple subjects can be created by instantiating new objects
    function Subject(svg, x, y, id, color, aoa, weight,timeInfected,infected,vaccinated) {
        this.positionX = x; // cx
        this.positionY = y; // cy
        this.color = color;
        this.radius = weight; // radius and weight same
        this.jumpSize = 1; // equivalent of speed default to 1
        this.svg = svg; // parent SVG
        this.id = id; // id of subject
        this.aoa = aoa; // initial angle of attack
        this.weight = weight;
		this.timeInfected = timeInfected;
		this.infected = infected;
		this.recovered = 0;
		this.deceased = 0;
		this.vaccinated = vaccinated;
		this.deathProbability = Math.random();
		

        if (!this.aoa)
            this.aoa = Math.PI / 7;
        if (!this.weight)
            this.weight = 10;
        this.radius = this.weight;

        this.data = [this.id]; // allow us to use d3.enter()

        //var this = this; // i like to use this instead of this. this many times not reliable particularly handling evnet

        // **** aoa is used only here -- earlier I was using to next move position.
        // Now aoa and speed together is velocity 
        this.velX = Math.cos(this.aoa) * this.jumpSize; // velocity x
        this.velY = Math.sin(this.aoa) * this.jumpSize; // velocity y
        this.initialVelX = this.velX;
        this.initialVelY = this.velY;
        this.initialPosX = this.positionX;
        this.initialPosY = this.positionY;

        // when speed changes, go to initial setting
        this.GoToInitialSettings = function (newjumpSize) {
            this.positionX = this.initialPosX;
            this.positionY = this.initialPosY;
            this.velX = Math.cos(this.aoa) * newjumpSize; // velocity x
            this.velY = Math.sin(this.aoa) * newjumpSize; // velocity y
            this.Draw();
        }

        this.Draw = function () {
            var svg = this.svg;
            var subject = svg.selectAll('#' + this.id)
                        .data(this.data);
			var stroke =  'none';
			if(maskWearing ==1)
				subject.style("stroke",'blue');
			
			if(this.infected == 0 && this.vaccinated == 1)
				this.color = "#0a4a90";
			
            
			subject.enter()
                .append("circle")
				.attr("id" , this.id)
				.attr('class' , 'subject')
				.attr('r' , this.radius)
				.attr('weight', this.weight)
				.attr("cx", this.positionX)
                .attr("cy", this.positionY)
                .style("fill", this.color)
				.style("stroke", stroke)
                ;
            
			subject
                //.transition()//.duration(50)
                .attr("cx", this.positionX)
                .attr("cy", this.positionY)
				.style("fill", this.color)
            ;
			
			
			
			

            // intersect subject is used to show collision effect - every subject has it's own intersect subject
            /*var intersectSubject = subject.enter()
                                .append('circle')
                                .attr({ 'id': this.id + '_intersect', 'class': 'intersectSubject' });*/
        }

        this.Move = function () {
            var svg = this.svg;

            //this.positionX += Math.cos(this.aoa) * this.jumpSize;
            //this.positionY += Math.sin(this.aoa) * this.jumpSize;

            this.positionX += this.velX;
            this.positionY += this.velY;

            if (parseInt(svg.attr('width')) <= (this.positionX + this.radius)) {
                this.positionX = parseInt(svg.attr('width')) - this.radius - 1;
                this.aoa = Math.PI - this.aoa;
                this.velX = -this.velX;
            }

            if ( this.positionX < this.radius) {
                this.positionX = this.radius+1;
                this.aoa = Math.PI - this.aoa;
                this.velX = -this.velX;
            }

            if (parseInt(svg.attr('height')) < (this.positionY + this.radius)) {
                this.positionY = parseInt(svg.attr('height')) - this.radius - 1;
                this.aoa = 2 * Math.PI - this.aoa;
                this.velY = -this.velY;
            }

            if (this.positionY < this.radius) {
                this.positionY = this.radius+1;
                this.aoa = 2 * Math.PI - this.aoa;
                this.velY = -this.velY;
            }

            
            if (this.aoa > 2 * Math.PI)
                this.aoa = this.aoa - 2 * Math.PI;
            if (this.aoa < 0)
                this.aoa = 2 * Math.PI + this.aoa;

            this.Draw();
        }
    }

    function CheckCollision(subject1, subject2) {
        var absx = Math.abs(parseFloat(subject2.positionX) - parseFloat(subject1.positionX));
        var absy = Math.abs(parseFloat(subject2.positionY) - parseFloat(subject1.positionY));

        // find distance between two subjects.
        var distance = (absx * absx) + (absy * absy);
        distance = Math.sqrt(distance);
        // check if distance is less than sum of two radius - if yes, collision
        if (distance < (parseFloat(subject1.radius) + parseFloat(subject2.radius))) {
            return true;
        }
        return false;
    }

    
    //courtsey thanks to several internet sites for formulas
    //detect collision, find intersecting point and set new speed+direction for each subject based on weight (weight=radius)
    function ProcessCollision(subject1, subject2) {

		
		
        if (subject2 <= subject1)
            return;
        if (subject1 >= (subjects.length-1) || subject2 >= subjects.length )
            return;

        subject1 = subjects[subject1];
        subject2 = subjects[subject2];

		
			
        if ( CheckCollision(subject1, subject2) ) {
            // intersection point
            var interx = ((subject1.positionX * subject2.radius) + subject2.positionX * subject1.radius)
            / (subject1.radius + subject2.radius);
            var intery = ((subject1.positionY * subject2.radius) + subject2.positionY  * subject1.radius)
            / (subject1.radius + subject2.radius);

            // show collision effect for 500 miliseconds
            /*var intersectSubject = svg.select('#' + subject1.id + '_intersect');
            intersectSubject.attr({ 'cx': interx, 'cy': intery, 'r': 5 ,'fill': 'black' })
                        .transition()
                        .duration(500)
                        .attr('r', 0);*/
			
			if(subject1.infected == 1 || subject2.infected == 1)
					{
					if(maskWearing == 1)
						{
						if ( Math.random() <= maskWearingInfectProb )
							{
							
							if(subject1.infected == 0 && subject1.recovered == 0 && subject1.deceased == 0 && subject1.vaccinated == 0)
								{
								subject1.timeInfected = timercount;
								subject1.color = 'red';
								subject1.infected = 1 ;
								infectedCount =  infectedCount + 1;
								uninfectedCount = uninfectedCount - 1;
								}
							
							if(subject2.infected == 0 && subject2.recovered == 0 && subject2.deceased == 0 && subject2.vaccinated == 0)
								{
								subject2.timeInfected = timercount;
								subject2.color = 'red';
								subject2.infected = 1 ;
								infectedCount =  infectedCount + 1;
								uninfectedCount = uninfectedCount - 1;
								}
							console.log('new covid infection');
							
							}
						}
						else
						{
						
						
						if(subject1.infected == 0 && subject1.recovered == 0 && subject1.deceased == 0 && subject1.vaccinated == 0)
							{
							subject1.timeInfected = timercount;
							subject1.color = 'red';
							subject1.infected = 1 ;
							infectedCount =  infectedCount + 1;
							uninfectedCount = uninfectedCount - 1;
							}
						
						if(subject2.infected == 0 && subject2.recovered == 0 && subject2.deceased == 0 && subject2.vaccinated == 0)
							{
							subject2.timeInfected = timercount;
							subject2.color = 'red';
							subject2.infected = 1 ;
							infectedCount =  infectedCount + 1;
							uninfectedCount = uninfectedCount - 1;
							}
						console.log('new covid infection');
						}
					}

            // calculate new velocity of each subject.
            var velX1 = (subject1.velX * (subject1.weight - subject2.weight)
                + (2 * subject2.weight * subject2.velX )) / (subject1.weight + subject2.weight);
            var velY1 = (subject1.velY * (subject1.weight - subject2.weight)
                + (2 * subject2.weight * subject2.velY)) / (subject1.weight + subject2.weight);
            var velX2 = (subject2.velX * (subject2.weight - subject1.weight)
                + (2 * subject1.weight * subject1.velX)) / (subject1.weight + subject2.weight);
            var velY2 = (subject2.velY * (subject2.weight - subject1.weight)
                + (2 * subject1.weight * subject1.velY)) / (subject1.weight + subject2.weight);

            //set velocities for both subjects
            subject1.velX = velX1;
            subject1.velY = velY1;
            subject2.velX = velX2;
            subject2.velY = velY2;

            //ensure one subject is not inside others. distant apart till not colliding
            while (CheckCollision(subject1, subject2)) {
                subject1.positionX += subject1.velX;
                subject1.positionY += subject1.velY;

                subject2.positionX += subject2.velX;
                subject2.positionY += subject2.velY;
				
				
				
            }
			
			
			
			subject1.Draw();
            subject2.Draw();
			legend.Draw();
        }
    }

    function Initialize(containerId) {
        var height = document.getElementById(containerId).clientHeight;
        var width = document.getElementById(containerId).clientWidth;
        gContainerId = containerId;
		
		
        subjects = [];
		gCanvasId = containerId + '_canvas';
		var svg = d3.select("#" + containerId);
		svg.selectAll("*").remove();
		gTopGroupId = containerId + '_topGroup';
        svg = d3.select("#" + containerId).append("svg")
            .attr("id", gCanvasId)
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("id", gTopGroupId)
            .attr("x", 0)
            .attr("y", 0)
            .attr("width", width)
            .attr("height", height)
            .style("fill", "none")
        //.attr("transform", "translate(" + 1 + "," + 1 + ")")
        ;
		
		
        
			for (var i = 1; i <= 44 ; ++i) {
				vaccinated = 0;
				if (Math.random() < percentPopVaccinated)
				{vaccinated = 1;
				vaccinatedCount = vaccinatedCount +1;}
				
				subjects.push(new Subject(svg, hi(i,bH,width), vi(i,bH,bV,height), 'n'+(i+1).toString(), "#b5d4e9", 2*Math.PI * Math.random(), 10,-1,0, vaccinated));
				}
			var j = 45
			
			subjects.push(new Subject(svg, hi(j,bH,width), vi(j,bH,bV,height), 'n' + (j+1).toString() , 'red', 2*Math.PI * Math.random(), 10,timercount,1,0));
			infectedCount +=1;
			uninfectedCount -=1;
			
			for (var i = 46; i <= popSize ; ++i) {
				vaccinated = 0;
				if (Math.random() < percentPopVaccinated)
				{vaccinated = 1;
				vaccinatedCount = vaccinatedCount +1;}
				
				subjects.push(new Subject(svg, hi(i,bH,width), vi(i,bH,bV,height), 'n'+(i+1).toString(), "#b5d4e9", 2*Math.PI * Math.random(), 10,-1,0, vaccinated));
				}

        for (var i = 0; i < subjects.length; ++i) {
            subjects[i].Draw();
        }
		
		legend = new Legend(svg,containerId);
		legend.Draw();
        return svg;
    }
	
	function Legend(svg, containerId)
		{
		var height = document.getElementById(containerId).clientHeight;
        var width = document.getElementById(containerId).clientWidth;
		this.gTopGroupId = containerId + '_leggendGroup';
		this.svg =  svg;
		this.g = this.svg.append("g")
			   .attr("id", this.gTopGroupId);
		
		var radious = 10;
		var legendWidth = 150;
		var legendHeight = 135;
		var padding = 5;
		var textSize = 16;
		this.Draw = function ()
			{var g = this.g;
			g.selectAll('*').remove();
		
			g.append("rect")
			 .attr("x", width - legendWidth)
			 .attr("y", 0)
			 .attr("width", legendWidth)
			 .attr("height", legendHeight)
			 .style("fill", "white")
			 .style("stroke", "black");
			
			g.append("circle")
			 .attr('r' , radious)
			 .attr("cx", width - legendWidth + radious + padding)
			 .attr("cy", radious + padding)
			 .style("fill", "red");
			g.append("text")
			 .attr("x", width - legendWidth + 2*radious + 2*padding)
			 .attr("y", radious + padding + textSize/2)
			 .text("Infected: " + infectedCount)
			 .style("font-size", textSize.toString() +"px")
			 .style("fill","black");
			
			g.append("circle")
			 .attr('r' , radious)
			 .attr("cx", width - legendWidth + radious + padding)
			 .attr("cy", 3*radious + 2*padding)
			 .style("fill", "orange");
			g.append("text")
			 .attr("x", width - legendWidth + 2*radious + 2*padding)
			 .attr("y", 3*radious + 2*	padding + textSize/2)
			 .text("Recovered: " + recoveredCount)
			 .style("font-size", textSize.toString() +"px")
			 .style("fill","black");
			
			g.append("circle")
			 .attr('r' , radious)
			 .attr("cx", width - legendWidth + radious + padding)
			 .attr("cy", 5*radious + 3*padding)
			 .style("fill", "#67000d");
			g.append("text")
			 .attr("x", width - legendWidth + 2*radious + 2*padding)
			 .attr("y", 5*radious + 3*padding + textSize/2)
			 .text("Deceased: " + deceasedCount)
			 .style("font-size", textSize.toString() +"px")
			 .style("fill","black");
			
			g.append("circle")
			 .attr('r' , radious)
			 .attr("cx", width - legendWidth + radious + padding)
			 .attr("cy", 7*radious + 4*padding)
			 .style("fill", "#b5d4e9");
			g.append("text")
			 .attr("x", width - legendWidth + 2*radious + 2*padding)
			 .attr("y", 7*radious + 4*padding + textSize/2)
			 .text("Uninfected: " + uninfectedCount)
			 .style("font-size", textSize.toString() +"px")
			 .style("fill","black");
			
			g.append("circle")
			 .attr('r' , radious)
			 .attr("cx", width - legendWidth + radious + padding)
			 .attr("cy", 9*radious + 5*padding)
			 .style("fill", "#0a4a90");
			g.append("text")
			 .attr("x", width - legendWidth + 2*radious + 2*padding)
			 .attr("y", 9*radious + 5*padding + textSize/2)
			 .text("Vaccinated: " + vaccinatedCount)
			 .style("font-size", textSize.toString() +"px")
			 .style("fill","black");
			}
		}
		
	
	// initial horizontal positioning
	function hi(a,bH,width) {
		  let result;
		  if (a%bH == 0) {
			result = bH;
		  } else {
			result = a%bH;
		  }
		  return Math.floor(25 + (result-1) *((width-50)/(bH-1)));
		}
	
	// initial vertical positioning
	function vi(a,bH,bV,height) {
		  let result;
			
		  var row = 0;
		  if (a%bH == 0) {
			row = Math.floor(a/bH)-1;
		  } else {
			row = Math.floor(a/bH);
		  }
		  result = Math.floor(25 + row * ((height-50)/(bV-1)));
		  
		  return result;
		}
	
	// infection transition to recovered or deceased
	function infectionExpiration(subject)
	{
		subject = subjects[subject];
		
		
		if(subject.infected == 1  && subject.recovered == 0  && subject.deceased == 0 && (timercount - subject.timeInfected)> infectionToDeathTime && subject.deathProbability <= deathRate)
			{
			subject.recovered = 0;
			subject.infected = 0;
			subject.deceased = 1
			subject.color = '#67000d';
			console.log('new covid death')
			deceasedCount = deceasedCount + 1;
			
			}
		
		if(subject.infected == 1  && subject.recovered == 0 && subject.deceased == 0 && (timercount - subject.timeInfected)> infectiousLength)
			{
			subject.recovered = 1;
			subject.infected = 0;
			subject.color = 'orange';
			console.log('new covid recovery')
			recoveredCount = recoveredCount +1;
			
			}
		
	}
    
    function StartStopToggle() {
		
        if (startStopFlag == 0) {
            timer =  d3.timer(function () 
			{
				timercount +=1;
                
				for (var i = 0; i < subjects.length; ++i)
					{
					
						var r = subjects[i].Move();
						infectionExpiration(i);
						for (var j = i + 1; j < subjects.length; ++j) {
							ProcessCollision(i, j);
						}
					}
			}, 500);
            startStopFlag = 1;
            document.getElementById('startStop').innerHTML = 'Stop';
        }
        else {
            startStopFlag = 0;
			timer.stop();
            document.getElementById('startStop').innerHTML = 'Start';
        }
    }

    
	
	
	
	function reStart(containerId)
		{
		
		
		gCanvasId = containerId + '_canvas';
		var svg = d3.select("#" + gCanvasId);
		svg.selectAll("*").remove();
		console.log(gCanvasId);
		deceasedCount = 0;
		infectedCount = 0;
		uninfectedCount = popSize;
		vaccinatedCount = 0;
		recoveredCount = 0;
		Initialize(containerId)
		}
	
	function onMaskWearingChange(containerId)
		{
		var maskWselect =  document.getElementById('maskWearingPopulation');
		maskWearing = maskWselect.options[maskWselect.selectedIndex].value;
		console.log("Mask Wearing: " + maskWearing);
		reStart(containerId);
		}
		
	function onPerPopVaccinatedChange(containerId)
		{
		var perPopSelect = document.getElementById('percentPopulationVaccinated');
		percentPopVaccinated =  perPopSelect.options[perPopSelect.selectedIndex].value;
		console.log("Per Population Vaccinated: " + percentPopVaccinated);
		reStart(containerId);
		}

</script>
<div id="simDiv" style="width:800px; height:600px; margin:0 auto;">
    <div id="drawAreaOuter" style="width:100%; height:100%;  ">
        <div id="menuTop" >
            <a id="startStop" href="javascript:StartStopToggle()">Start</a> | 
			<a id="restart" href="javascript:reStart('drawArea')">Restart</a> 
             | Mask Wearing :
            <select id='maskWearingPopulation' onchange="onMaskWearingChange('drawArea')">
                <option value="0" selected="selected">No</option>
                <option value="1" >Yes</option>
                
            </select>
			 | % Pop Vaccinated :
            <select id='percentPopulationVaccinated' onchange="onPerPopVaccinatedChange('drawArea')">
                <option value=0 selected="selected">0 %</option>
                <option value=0.35 >35%</option>
                <option value=0.45 >45%</option>
				<option value=0.55 >55%</option>
				<option value=0.65 >65%</option>
				<option value=0.75 >75%</option>
            </select>
        </div>
        <div id="drawArea" style="width:100%; height:100%; border:1px solid gray">
        </div>
    </div>
</div>

<script>
    var svg = Initialize('drawArea');
</script>
<p ><o:p>&nbsp;</o:p></p>
<p>For this simulation, we assume that for mask wearing people,
the chances of infection is of 94% (<a
href="https://www.cdc.gov/mmwr/volumes/69/wr/mm6947e2.htm">CDC</a>), the nature
of the simulation includes random directions and random people who use masks or
is vaccinated, different runs can lead to different results*.</p>

<p ><o:p>&nbsp;</o:p></p>

<script>

var rollingData = null;
var counties = [];
var xCurrSituationScale = null;
var colorCurrSituation = null;
var currSitColorDomain = [];
var xCurrSitColorRange = [];
const currSitColorRange = ["#fff5f0","#fee3d6","#fdc9b4","#fcaa8e","#fc8a6b","#f9694c","#ef4533","#d92723","#bb151a","#970b13","#67000d"];
const margin = 40;
const steps = 10;
const legendWidth = 250;

async function initCurrentStateMap(containerId)
	{
	rollingData = await d3.csv('https://raw.githubusercontent.com/nytimes/covid-19-data/master/rolling-averages/us-counties-recent.csv');
	rollingData.forEach(function(data){
      data.id = data.geoid.slice(4,9)
    })
	
	usMap = await d3.json("https://d3js.org/us-10m.v1.json");
	
	
	
	var maxDate = d3.max(rollingData, function(d) { return d.date; });
	
	//console.log('Max Date:' + maxDate);
	
	
	latestRollingData = rollingData.filter(function (d) {return d['date'] == maxDate;})
	console.log(latestRollingData);
	
	var maxCasesAvg100K = Math.ceil(d3.max(latestRollingData, function(d) { return d.cases_avg_per_100k; }));
	//console.log('Max Cases AVG:' + maxCasesAvg100K);
	
	var height = document.getElementById(containerId).clientHeight;
	var width = document.getElementById(containerId).clientWidth;
	
	
	d3.select("#" + containerId).select('*').remove();
	counties = [];
	gCanvasId = containerId + '_canvas';
	
	var svg = d3.select("#" + containerId).append("svg")
		.attr("id", gCanvasId)
		.attr("width", width)
		.attr("height", height);
	
	casesAVG100Kstep = maxCasesAvg100K / steps;
	xCurrSitColorRangeStep = (legendWidth)/steps;
	xCurrSitColorRange.push(width - legendWidth - margin)
	for (var i = 1; i <= steps ; ++i) {
				currSitColorDomain.push( i*casesAVG100Kstep );
				xCurrSitColorRange.push(width - legendWidth - margin + xCurrSitColorRangeStep *i)
				}
	//console.log(currSitColorDomain);
	//console.log(xCurrSitColorRange);
	
	xCurrSituationScale = d3.scaleThreshold()
								.domain(currSitColorDomain)
								.range(xCurrSitColorRange);
	
	colorCurrSituation = d3.scaleThreshold()
							   .domain(currSitColorDomain)
							   .range(currSitColorRange);
	
	
	
	drawInfectionRateGradientScale(svg, containerId, height, width);
	draUSMap(svg,containerId, latestRollingData, usMap, height, width);
	drawTimeStamp(svg, containerId, height, width, maxDate);
    }

function draUSMap(svg,containerId, latestRollingData, usMap, height, width)
{
	var pairAVGCasesWithId = {};
	var pairNameWithId = {};
	var path = d3.geoPath();
	latestRollingData.forEach(function(d) {
		pairAVGCasesWithId[d.id] = +d.cases_avg_per_100k;
		pairNameWithId[d.id] = d.county + ' County, '+ d.state;});

	gCurrSituationGroup = containerId + '_currSitMap';
	g = svg.append("g")
		.attr("id", gCurrSituationGroup)
		.attr("x", 0)
		.attr("y", 0)
		.attr("width", width)
		.attr("height", height)
		.attr('transform','translate(0,50)')
		.style("fill", "none");

	g.selectAll("path")
		 .data(topojson.feature(usMap, usMap.objects.counties).features)
		 .enter().append("path")
		 .attr("d", path)
		 .attr("stroke", "#b5d4e9")
		 .attr("stroke-width", 0.5)
		 .style ( "fill" , function (d) {return colorCurrSituation (pairAVGCasesWithId[d.id]); })
		 .append("title")
		 .text(function(d) { return pairNameWithId[d.id] +': ' + pairAVGCasesWithId[d.id] + ' per100K'; });
	g = svg.append("g")
		.attr("id", gCurrSituationGroup + '_states')
		.attr("x", 0)
		.attr("y", 0)
		.attr("width", width)
		.attr("height", height)
		.attr('transform','translate(0,50)')
		.style("fill", "none");
		
	g.selectAll("path")
		.data(topojson.feature(usMap, usMap.objects.states).features)
		.enter().append("path")
		.attr("d", path)
		.attr("stroke", "#000")
		.attr("stroke-width", 0.5)
		.style('fill','none');

}

function drawInfectionRateGradientScale(svg, containerId, height, width)
	{
	gCurrSituationGroup = containerId + '_currSitMapGradScale';
	// Draw canvas
	g = svg.append("g")
		.attr("id", gCurrSituationGroup)
		.attr("x", 0)
		.attr("y", 0)
		.attr("width", width)
		.attr("height", height)
		.attr('transform','translate(0,40)')
		.style("fill", "none");
		

	g.selectAll("rect")
     .data(colorCurrSituation.range().map(function(d) {
      d = colorCurrSituation.invertExtent(d);
      if (d[0] == null) d[0] = xCurrSituationScale.domain()[0];
      if (d[1] == null) d[1] = xCurrSituationScale.domain()[1];
      return d;
    }))
	.enter().append("rect")
    .attr("height", 8)
    .attr("x", function(d) {  return xCurrSituationScale(d[0]) })
    .attr("width", xCurrSitColorRangeStep)
    .attr("fill", function(d) { return colorCurrSituation(d[0]); });

	g.append("text")
     .attr("class", "caption")
     .attr("x", width - legendWidth + 80)
     .attr("y", -6)
     .attr("fill", "#000")
     .attr("text-anchor", "start")
     .attr("font-weight", "bold")
     .text("Cases per 100K");

	g.call(d3.axisBottom(xCurrSituationScale)
     .tickSize(10)
     
     .tickValues(colorCurrSituation.domain()))
     .select(".domain")
     .remove();
	}
	
function drawTimeStamp(svg, containerId, height, width, maxDate)
	{
	gCurrSituationGroup = containerId + '_currSitTimeStamp';
	// Draw canvas
	g = svg.append("g")
		.attr("id", gCurrSituationGroup)
		.attr("x", 0)
		.attr("y", 0)
		.attr("width", width)
		.attr("height", height)
		.attr('transform','translate(0,40)')
		.style("fill", "none");
	g.append("text")
     .attr("class", "timeStamp")
     .attr("x", width - 150)
     .attr("y", height - 50)
     .attr("fill", "#000")
     .attr("text-anchor", "start")
     .text("As of: " +  maxDate);
	}
		

initCurrentStateMap('currentStateMap')	;


</script>
<div id="currSituationDiv" style="width:960px; height:700px; margin:0 auto;">
	<div id="currentStateMap" style="width:100%; height:100%; border:1px solid gray">
	
    </div>
</div>

<p >Source: <A href ='https://github.com/nytimes/covid-19-data/tree/master/rolling-averages'>NY Times Rolling data</A>. Cases per 100K represent the Average number of cases per every 100K persons among the population in the last 7 days. </p>

<script>

var hesitancyData = null;
var hesitancyColorDomain = [];
var xHesitancyColorRange = [];
const hesitancyColorRange = ["#f7fcf0","#e5f5df","#d3eece","#bde5bf","#9ed9bb","#7bcbc4","#58b7cd","#399cc6","#1d7eb7","#0b60a1","#084081"];
var xHesitancyScale = null;
var colorHesitancy = null;


async function initHesitancyMap(containerId)
	{
	hesitancyData = await d3.csv('https://raw.githubusercontent.com/jdfloresd/dataVizProject/main/Vaccine_Hesitancy_for_COVID-19_County_and_local_estimates_no_boundaries.csv');
	//console.log(hesitancyData);
	usMap = await d3.json("https://d3js.org/us-10m.v1.json");
	var height = document.getElementById(containerId).clientHeight;
	var width = document.getElementById(containerId).clientWidth;
	d3.select("#" + containerId).select('*').remove();
	
	gCanvasId = containerId + '_canvas';
	
	var svg = d3.select("#" + containerId).append("svg")
		.attr("id", gCanvasId)
		.attr("width", width)
		.attr("height", height);
	var maxhesitancy = d3.max(hesitancyData, function(d) { return d.Estimated_hesitant_or_unsure; });
	
	//console.log(maxhesitancy)
	
	var steps = 10;
	
	var hesitancyStep = maxhesitancy / steps;
	xHesitancyColorRangeStep = (legendWidth)/steps;
	xHesitancyColorRange.push(width - legendWidth - margin)
	for (var i = 1; i <= steps ; ++i) {
				hesitancyColorDomain.push((i*hesitancyStep).toFixed(2) );
				xHesitancyColorRange.push(width - legendWidth - margin + xHesitancyColorRangeStep *i)
				}
	//console.log(hesitancyColorDomain);
	//console.log(xHesitancyColorRange);
	
	xHesitancyScale = d3.scaleThreshold()
								.domain(hesitancyColorDomain)
								.range(xHesitancyColorRange);
	
	colorHesitancy = d3.scaleThreshold()
							   .domain(hesitancyColorDomain)
							   .range(hesitancyColorRange);
	
	drawHesitancyGradientScale(svg, containerId, height, width);
	draHesitancyUSMap(svg,containerId, hesitancyData, usMap, height, width)
							   
	}

function drawHesitancyGradientScale(svg, containerId, height, width)
	{
	gHesitancyGroup = containerId + '_hesitancyMapGradScale';
	// Draw canvas
	g = svg.append("g")
		.attr("id", gHesitancyGroup)
		.attr("x", 0)
		.attr("y", 0)
		.attr("width", width)
		.attr("height", height)
		.attr('transform','translate(0,40)')
		.style("fill", "none");
		

	g.selectAll("rect")
     .data(colorHesitancy.range().map(function(d) {
      d = colorHesitancy.invertExtent(d);
      if (d[0] == null) d[0] = xHesitancyScale.domain()[0];
      if (d[1] == null) d[1] = xHesitancyScale.domain()[1];
      return d;
    }))
	.enter().append("rect")
    .attr("height", 8)
    .attr("x", function(d) {  return xHesitancyScale(d[0]) })
    .attr("width", xHesitancyColorRangeStep)
    .attr("fill", function(d) { return colorHesitancy(d[0]); });

	g.append("text")
     .attr("class", "caption")
     .attr("x", width - legendWidth + 80)
     .attr("y", -6)
     .attr("fill", "#000")
     .attr("text-anchor", "start")
     .attr("font-weight", "bold")
     .text("Hesitancy Rate:");

	g.call(d3.axisBottom(xHesitancyScale)
     .tickSize(10)
     .tickValues(colorHesitancy.domain()))
     .select(".domain")
     .remove();
	}

function draHesitancyUSMap(svg,containerId, hesitancyData, usMap, height, width)
{
	var pairHesitancyRateWithId = {};
	var pairNameWithId = {};
	var path = d3.geoPath();
	hesitancyData.forEach(function(d) {
		pairHesitancyRateWithId[d.FIPS_Code] = +d.Estimated_hesitant_or_unsure;
		pairNameWithId[d.FIPS_Code] = d.County_Name;});
	//console.log(pairHesitancyRateWithId)

	gHesitancyGroup = containerId + '_hesitancyMap';
	g = svg.append("g")
		.attr("id", gHesitancyGroup)
		.attr("x", 0)
		.attr("y", 0)
		.attr("width", width)
		.attr("height", height)
		.attr('transform','translate(0,50)')
		.style("fill", "none");

	g.selectAll("path")
		 .data(topojson.feature(usMap, usMap.objects.counties).features)
		 .enter().append("path")
		 .attr("d", path)
		 .attr("stroke", "#fdca94")
		 .attr("stroke-width", 0.5)
		 .style ( "fill" , function (d) {return colorHesitancy (pairHesitancyRateWithId[d.id]); })
		 .append("title")
		 .text(function(d) { return pairNameWithId[d.id] +': ' + pairHesitancyRateWithId[d.id]; });
	
	g = svg.append("g")
		.attr("id", gHesitancyGroup + '_states')
		.attr("x", 0)
		.attr("y", 0)
		.attr("width", width)
		.attr("height", height)
		.attr('transform','translate(0,50)')
		.style("fill", "none");
		
	g.selectAll("path")
		.data(topojson.feature(usMap, usMap.objects.states).features)
		.enter().append("path")
		.attr("d", path)
		.attr("stroke", "#000")
		.attr("stroke-width", 1)
		.style('fill','none');

}
	
initHesitancyMap('hesitancyMap')

</script>

<div id="hesitancyDiv" style="width:960px; height:700px; margin:0 auto;">
	<div id="hesitancyMap" style="width:100%; height:100%; border:1px solid gray">
	
    </div>
</div>

<p ><o:p>&nbsp;</o:p></p>

<p >Source: <A href="https://data.cdc.gov/Vaccinations/Vaccine-Hesitancy-for-COVID-19-County-and-local-es/q9mh-h2tw">CDC</A>. Hesitancy Rate represents the rate of adults who describe themselves as “unsure”, “probably not”, or “definitely not” going to get a COVID-19 vaccine once one is available to them, based on national survey data. </p>

<p ><o:p>&nbsp;</o:p></p>

<p >As seen on our infections simulation, a rate of vaccination
of 75% or higher will most likely stop the spread of Covid-19, but vaccination
hesitancy stands on its way. The World Economic Forum (<span class=SpellE><a
href="https://www.weforum.org/agenda/2021/06/3-tactics-to-overcome-covid-19-vaccine-hesitancy/">WeForum</a></span>),
offers some guidance on what can be done to overcome this hesitancy, basically
it proposes increasing the awareness of the different aspects of the COVID
Vaccine development process, side-effects, this can be done by local authorities,
with help of local leaders. Then Improve the feeling that people have developed
against the vaccine by using information sources trusted by people who are
hesitant, like their personal doctors, pastors, etc. and Finally, facilitate the
action of people taking the vaccine, that is, for example offer incentives,
taking the vaccines to patients directly, via mobile units, making them
available in their workplaces, offering free transportation, etc.</p>

<p ><o:p>&nbsp;</o:p></p>

<p >*The simulation on this page is for illustration purposes
only, it does not take into account multiple aspects of <span class=GramE>real
life</span> transmissions.</p>

</div>

</body>

</html>
